"""
Django settings for config project.

Generated by 'django-admin startproject' using Django 2.1.4.

For more information on this file, see
https://docs.djangoproject.com/en/2.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.1/ref/settings/
"""
#
# import os
#
import environ

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
#
# os.path.join(BASE_DIR, ...) replaced with ROOT_DIR an easier way to describe paths
#
# BASE_DIR is typically used for building more file path variables off of the project’s top level (commonly known as root directory), i.e. finding another file or a directory of files.
#
# Now that we have environ instead of os, we can replace BASE_DIR with another variable called ROOT_DIR. (or simply rename it, if you wish, or don’t, ROOT_DIR just makes more logical sense for the structure).
#
# This function gets the current files path ~/git/modern-django/config/base.py and moves up three levels to ~/git/modern-django/. Now, we have a variable that points to the root of the project and we can get any other file in the directory from it.
#
# To demonstrate that we can access any other file, we will create another variable called APPS_DIR. This will point it at a folder 'project' we have not created yet that will later hold the applications we create.

ROOT_DIR = environ.Path(__file__) - 3
APPS_DIR = ROOT_DIR.path('project')
HOME_DIR = environ.Path(__file__) - 5
PYTHONPATH = HOME_DIR.path('.local','bin')

env = environ.Env()

# This section added from an update to standards in CookieCutter Django to ensure no errors are encountered at runserver/migrations
#
# Below our newly created ROOT_DIR and APPS_DIR, we will import a large number of environment variables to use in the project from a file called .env (we’ll make that soon). We will use the environ.Env() function that will find a .env file in our project root, then read_env() to make use of them.
#
# The main purpose of adding this functionality in now is so that when using Docker containers, we will be reading environment variables from the .env file, as there are some complications with doing so in Docker.

READ_DOT_ENV_FILE = env.bool('DJANGO_READ_DOT_ENV_FILE', default=False)

if READ_DOT_ENV_FILE:
    env_file = str(ROOT_DIR.path('.env'))
    print('Loading : {}'.format(env_file))
    env.read_env(env_file)
    print('The .env file has been loaded. See base.py for more information')

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!


# SECURITY WARNING: don't run with debug turned on in production!
#
# Using DEBUG as True should only be used in local development, and thus we should also make a copy in local.py. Copy and paste the DEBUG setting into local.py and overwrite the environment variable by setting it to True.

DEBUG = env.bool('DJANGO_DEBUG', False)

# ALLOWED_HOSTS is the list of sites that Django will accept to make connection and requests. For local development when DEBUG is True, we can have this be empty, however, when in production it must be set to a specific domain such as .example.com

ALLOWED_HOSTS = []


# INSTALLED APPS
# The INSTALLED_APPS array is the list of applications that the Django project is aware of. It is initialized with a number of default Django applications that run the base project. Typically, projects would simply add in applications as they are installed by pip or created by the engineers. However, for organization will split up the INSTALLED_APPS section into three tuples: DJANGO_APPS, THIRD_PARTY_APPS, and LOCAL_APPS. After we populate the three sections, we will add them together to make the INSTALLED_APPS list.

# Note: The usage of tuples, over lists, is because they are immutable and the ease of concatenating them together. Their immutability also ensures, that, at runtime, the project’s installed apps cannot be changed.

DJANGO_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
)

THIRD_PARTY_APPS = (
)

LOCAL_APPS = (
)

INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS

# MIDDLEWARE
# We now find ourselves in front of the illusive MIDDLEWARE. The concept of middleware is taking  requests/responses (HTTP communication) as they enter/leave the Django system and applying functions to them before/after being processed in a light weight manner. Such an example is AuthenticationMiddleware, which can associate a user with a request when user sessions are being used. These functions are done extremely fast and help add data we can process against.

# IMPORTANT: The order in which middleware are placed in the MIDDLEWARE list is the order in which they will be processed. That means specific middleware must go above others, or else unexpected behavior may occur.

# The Django documentation describes this process like layers of an onion, where a View (and its children) is at the center and a request must go through each wrapping layer of middleware in order, before being manipulated by the view.

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

#
# The ROOT_URLCONF points to the URLconf module (a collection of URL guidelines) that Django will handles requests/responses with. Essentially, when a user makes a request to a page/resource in one of our apps, Django looks in that file to determine what to do. That is, the ROOT_URLCONF points to a file that contains a set of URLs such myproject/config/urls.py. The current pointer is the default, and we will add more URLs to the file, such as those to our REST API, later. Currently, you can find it extending to the admin app’s URLs.
#

ROOT_URLCONF = 'config.urls'

#
# The TEMPLATES setting is a list of settings that are applied to the template engines installed. Multiple can be installed, however most projects will only need one. The default settings include:

#    BACKEND: the processor for creating templates
#    DIRS: directories that Django will look for template files
#    APP_DIRS: set to True, Django will automatically look in each app in the INSTALLED_APPS list for templates that could possibly be rendered
#    OPTIONS: extra options that depend on the BACKEND
#    context_processors: an option that is for the DjangoTemplates engine, that determine how data is rendered on a template.
#
#
#For the purposes of transparency, we will most likely gut this portion later, as we intend to use a true JavaScript frontend with our API.
#

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

#
# “WSGI” stands for Web Server Gateway Interface. It is a standard for Python web frameworks that point a server at an application.
#
# WSGI_APPLICATION points to the wsgi.py file that Django will serve when the runserver command is executed. It contains an application as a callable and will point the current settings being used at that application. This is essential for running our application.
#

WSGI_APPLICATION = 'config.wsgi.application'


# Database
# https://docs.djangoproject.com/en/2.1/ref/settings/#databases
#
# The DATABASES settings are those that connect different databases to our project. They store the settings needed to interact with different databases. The default database is a locally stored sqlite3 database (that has not been created yet, as we have done no database manipulation. Yet.). We will later on update this to include a PostgreSQL database when we begin working with Docker.
#
# Again, we have encountered another use of os, thus we should change it to work with a path created by environ. Replace the NAME line as follows:
#
#
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
#        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
        'NAME': str(ROOT_DIR.path('db.sqlite3')),
    }
}


#
# Password validation
# https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators
#
# This configuration is a set of rules that passwords must be verified by when created or edited by users. The defaults are robust enough to reduce a large portion of attacks and require no additions. You can create custom validators for increased security:
# https://docs.djangoproject.com/en/2.1/topics/auth/passwords/#password-validation 
#

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/2.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.1/howto/static-files/
#
# Static files are files that are considered not changing, static. This includes files, such as images, CSS, and JavaScript that are used in the application. Media files are considered dynamic files created/edited/uploaded by users. The majority of rules below apply to both Static and Media files.
#
# We now find ourselves at one of the hardest concepts to grasp for new Django users. There is one standard use case for how static/media file serving should be done, but many users become confused on how to do it.
#
# It is extremely important to understand that static files currently live in separate directories, per app. That location is not the location they will be served from in production.
#
# An example, the CSS files used on the Admin panel will not be served from its own static directory of the admin application in production. The manage.py command, collectstatic, will be used when deploying. This will copy all static files this settings file knows about, into a root level folder defined by STATIC_ROOT. Then, a server, such as nginx, will retrieve and serve those files.
# 
# HOWEVER, on local development, Django will simply serve them from the directories they originally live in.
# 
# Currently, STATIC_URL is the only static settings created by default. This is the URL that static files will be served at. Currently, the files will be served at localhost:8000/static, if localhost:8000 is used for local development.
# 
# We will add the following:
# 
#     STATIC_ROOT: where the collected static files will be placed
#     STATICFILES_DIRS: folders Django will look for static files in
#     STATICFILES_FINDERS: specifications on what files to look for
#     MEDIA_URL: URL appended to the root URL to serve media data
#     MEDIA_ROOT: where the collected media files will be stored
# 
# Make these additions to Static and Media settings where STATIC_URL is defined in base.py:

STATIC_URL = '/static/'

STATIC_ROOT = str(ROOT_DIR('staticfiles'))

STATICFILES_DIRS = (
    str(APPS_DIR.path('static')),
)

STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
)

MEDIA_URL = '/media/'

MEDIA_ROOT = str(APPS_DIR('media'))


#

